#!/usr/bin/env ruby

require 'wukong'

settings = Wukong::Local::Configuration
settings.use(:commandline)

def settings.usage
  "usage: #{File.basename($0)} PROCESSOR|FLOW [ --param=value | -p value | --param | -p]"
end

settings.description = <<-EOF
wu-local is a tool for running Wukong processors and flows locally on
the command-line.  Use wu-local by passing it a processor and feeding
in some data:

  $ echo 'UNIX is Clever and Fun...' | wu-local tokenizer.rb
  UNIX
  is
  Clever
  and
  Fun

If your processors have named fields you can pass them in as
arguments:

  $ echo 'UNIX is clever and fun...' | wu-local tokenizer.rb --min_length=4
  UNIX
  Clever

You can chain processors and calls to wu-local together:

  $ echo 'UNIX is clever and fun...' | wu-local tokenizer.rb --min_length=4 | wu-local downcaser.rb
  unix
  clever

Which is a good way to develop a combined data flow which you can
again test locally:

  $ echo 'UNIX is clever and fun...' | wu-local tokenize_and_downcase_big_words.rb
  unix
  clever
EOF

settings.define :run,        description: "Name of the processor or dataflow to use.  Defaults to basename of the given path.", flag: 'r'
settings.define :tcp_server, description: "Run locally as a tcp server on a specified port", default: false,                    flag: 't'
require 'wukong/boot' ; Wukong.boot!(settings)

thing = settings.rest.first
case
when thing.nil?
  settings.dump_help
  exit(1)
when Wukong.registry.registered?(thing.to_sym)
  processor = thing.to_sym
when File.exist?(thing)
  load thing
  processor = settings.run || File.basename(thing, '.rb')
else
  settings.dump_help
  exit(2)
end

begin
  EM.run do
    settings.tcp_server ? Wu::TCPServer.start(processor.to_sym, settings) : Wu::StdioServer.start(processor.to_sym, settings)
  end
rescue Wu::Error => e
  $stderr.puts e.message
  exit(3)
end

# One day, it will be this easy...
# Wukong::LocalRunner.run!
